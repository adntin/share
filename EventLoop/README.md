# 事件循环系统

> 每个渲染进程都有一个主线程，主线程是非常繁忙。它要处理内部消息任务，如 DOM 操作、微任务、文件读写、WebSocket、JavaScript 定时器等。还需要处理很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。[消息队列任务类型 - Chromium 官方源码](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/public/platform/task_type.h)。以上这些任务和事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

## 页面使用单线程的缺点

如何处理高优先级的任务?

> 比如监听 DOM 变化（插入、修改、删除），然后处理业务逻辑。当变化频繁发生时，同步执行时，当前的任务执行时间被拉长，执行效率下降; 异步执行时，可能在添加到消息队列的过程中，前面可能有很多任务在排队，实时性下降。

> 通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了**执行效率**的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了**实时性**的问题。

如何解决单个任务执行时长过久的问题?

> JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。
