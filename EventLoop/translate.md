# 8.1.6 Event loops - 事件循环

[Event loops](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)

## 8.1.6.1 Definitions - 定义

为了协调事件、用户交互、脚本、渲染、网络等，用户代理（浏览器）必须使用本节所述的事件循环。每个代理都有一个关联的事件循环，它对该代理来说是唯一的。

`同源窗口代理 similar-origin window agent`的事件循环称为`窗口事件循环 window event loop`。`专用工作线程代理 dedicated worker agent`、`共享工作线程代理 shared worker agent`或`服务工作线程代理 service worker agent`的事件循环称为`工作线程事件循环 worker event loop`。`轻量级工作线程代理 worklet agent`的事件循环称为`轻量级工作线程事件循环 worklet event loop`。

PS: Worklet(工作草案) - Worker 的轻量级版本，让开发人员可以访问渲染管道的底层部分。通过 Worklet，您可以运行 JavaScript 和 WebAssembly 代码来执行需要高性能的图形渲染或音频处理。

> 注意
> 事件循环不一定对应于实现上的线程。例如: 多个窗口事件循环可以在同一个线程里调度。
> 然而，对于将[[CanBlock]]设置为 true 的各种工作线程代理，JavaScript 标准对它们提出了关于前进进度的要求，这种情况下事实上要求了每个代理有自己的线程。

事件循环`event loop`有一个或多个任务队列`task queues`。任务队列是一组任务`tasks`。

> 注意
> `任务队列 task queues`是`集合 sets`，而不是`队列 queues`，因为`事件循环处理模型的第一步`从所选队列中获取第一个`可运行任务`，而不是从`队列中取出`第一个任务。
> 注意
> 微任务队列`microtask queue`不是任务队列`task queue`。

任务封装了负责如下工作的算法:

**Events - 事件**
在特定的`EventTarget`对象上派发`Event`对象，通常是由专门的任务完成。

> 注意
> 不是所有的事件都是使用`任务队列`派发的; 很多是在其他任务执行过程中派发的。

**Parsing - 解析**
HTML 解析器词发分析一个或更多字节，然后处理结果标记。这通常是一个任务。

**Callbacks - 回调**
调用一个回调通常是由专用任务来完成的。

**Using a resource - 使用一个资源**
当一个算法获取一个资源时，如果获取发生在一个非阻塞的情况，那么一旦某个或全部资源可用，对资源的处理由一个任务来执行。

**Reacting to DOM manipulation - 对 DOM 操作作出反应**
有些元素在 DOM 操作时会触发一些任务，例如: 当元素 插入到文档中 时。

正式情况，任务是一个具有如下的结构:

**Steps - 步骤**
一系列的步骤，指定了要完成的工作。

**A source - 一个来源**
任务来源之一，用于分组和序列化相关任务。

**A document - 一个文档**
和任务关联的 Document，对于不在窗口事件循环里的任务为 null。

**A script evaluation environment settings object set - 脚本执行环境设置对象集合**
用于在任务期间跟踪脚本执行的环境设置对象的集合。

任务 是 可执行的 当且仅当它的 document 为 null 或 完全激活。

至于它的 source 字段，每个 任务 都来自一个特定的 任务源。 事件循环 中的每个 任务源 必须关联 特定的 任务队列。

> 注意
> 本质上，任务源 用于分离逻辑上不同类型的任务，用户代理可能希望区分它们。 用户代理使用 任务队列 来在给定的 事件循环 内合并任务源。
> 示例
> 例如，用户代理可以有一个鼠标和键事件的任务队列（用户交互任务源与之相关联），另一个任务队列与所有其他任务源相关联。 然后，使用在事件循环处理模型的初始步骤中授予的自由度，它可以在四分之三的时间内给予键盘和鼠标事件优先于其他任务的优先权，保持界面响应但不会使其他任务队列挨饿。 请注意，在此设置中，处理模型仍然强制用户代理永远不会无序处理来自任何一个任务源的事件。

每个`事件循环`都有一个`当前正在运行的任务`，它要么是一个任务，要么是空的。 最初，这是空的。用来处理再次进入的情况。
每个`事件循环`都有一个`微任务队列`， 它是一个`微任务`的`队列`，初始为空。`微任务`是一个通俗的叫法，指由`入队微任务`算法创建的`任务`。
每个`事件循环`都有一个`执行微任务检查点` 布尔值，初始为假。它用来防止重新进入`微任务检查点`的调用。

## 8.1.6.2 Queuing tasks - 排队的任务

## 8.1.6.3 Processing model - 处理模型

事件循环只要存在，就会不断执行以下步骤:

1. 让 taskQueue 作为事件循环的任务队列之一，以实现定义的方式选择，约束条件是所选任务队列必须包含至少一个可运行任务。 如果没有这样的任务队列，则跳转到下面的微任务步骤。
   > 注意：请记住，微任务队列不是任务队列，因此在这一步中不会选择它。 但是，在此步骤中可能会选择与微任务任务源相关联的任务队列。 在这种情况下，下一步选择的任务最初是一个微任务，但它作为旋转事件循环的一部分被移动了。
2. 让 oldestTask 成为 taskQueue 中第一个可运行的任务，并将其从 taskQueue 中移除。
3. 将事件循环当前运行的任务设置为 oldestTask。
4. 让 taskStartTime 作为当前的高解析度时间。
5. 执行 oldestTask 的步骤。
6. 将事件循环当前正在运行的任务设置回 null。
7. 微任务：执行微任务检查点。
8. 让 hasARenderingOpportunity 为 false。
9. 让 now 作为当前的高解析度时间。
10. 通过执行以下步骤报告任务的持续时间：
    1. 让顶级浏览上下文为空集。
    2. 对 oldestTask 的 脚本执行环境设置对象集合 的每个 环境设置对象 的 `settings`， 追加 `setting` 的 顶级浏览上下文 到 顶级浏览上下文。
    3. 上报长任务，传入 taskStartTime、now（任务结束时间）、顶级浏览上下文、oldestTask。
11. 更新渲染：如果这是一个窗口事件循环，则：
    1. 令 docs 为其相关代理的事件循环是此事件循环的所有 Document 对象，任意排序，但必须满足以下条件：
       - 任何浏览上下文的容器文档为 A 的文档 B 都必须列在列表中的 A 之后。
       - 如果有两个文档 A 和 B 的浏览上下文都是子浏览上下文，其容器文档是另一个文档 C，则列表中 A 和 B 的顺序必须与 C 中各自浏览上下文容器的包含阴影的树顺序匹配节点树。
         在下面迭代文档的步骤中，必须按照在列表中找到的顺序处理每个文档。
    2. 渲染机会：从文档中删除浏览上下文没有渲染机会的所有 Document 对象。
       如果用户代理当前能够将浏览上下文的内容呈现给用户，则浏览上下文有一个呈现机会，考虑到硬件刷新率限制和出于性能原因的用户代理节流，但考虑内容即使在视口之外也是可呈现的。
       浏览上下文呈现机会是根据硬件约束（例如显示刷新率）和其他因素（例如页面性能或页面是否在后台）来确定的。 渲染机会通常定期发生。
       > 注意: 本规范不强制要求任何特定模型来选择渲染机会。 但是例如，如果浏览器试图达到 60Hz 的刷新率，那么渲染机会最多每 60 秒（大约 16.7 毫秒）发生一次。 如果浏览器发现浏览上下文无法维持此速率，它可能会降低该浏览上下文的每秒 30 次渲染机会，而不是偶尔丢帧。 类似地，如果浏览上下文不可见，用户代理可能会决定将该页面降低到每秒 4 次渲染机会，甚至更少。
    3. 如果 docs 不为空，则将 hasARenderingOpportunity 设置为 true。
    4. 不必要的渲染：从文档中删除满足以下两个条件的所有 Document 对象：
       - 用户代理认为更新 Document 浏览上下文的渲染不会有明显的效果，并且
       - 文档的动画帧回调映射为空。
    5. 从文档中删除用户代理认为由于其他原因最好跳过更新渲染的所有 Document 对象。
       > 注意: 标记为渲染机会的步骤可防止用户代理在无法向用户呈现新内容（没有渲染机会）时更新渲染。
       > 标记为不必要的渲染的步骤可防止用户代理在没有要绘制的新内容时更新渲染。
       > 此步骤使用户代理能够防止以下步骤因其他原因而运行，例如，确保某些任务在彼此之后立即执行，只有微任务检查点交错（并且没有，例如，动画帧回调交错）。 具体来说，用户代理可能希望将计时器回调合并在一起，而没有中间渲染更新。
    6. 对于文档中的每个完全活动的文档，如果其浏览上下文是顶级浏览上下文，则刷新该文档的自动对焦候选对象。
    7. 对于文档中的每个完全活动的文档，运行该文档的调整大小步骤，现在作为时间戳传入。
    8. 对于文档中的每个完全活动的文档，运行该文档的滚动步骤，现在作为时间戳传入。
    9. 对于文档中的每个完全活动的文档，评估媒体查询并报告该文档的更改，现在作为时间戳传入。
    10. 对于文档中的每个完全活动的文档，更新动画并为该文档发送事件，现在作为时间戳传入。
    11. 对于文档中的每个完全活动的文档，运行该文档的全屏步骤，现在作为时间戳传入。
    12. 对于文档中的每个完全活动的文档，如果用户代理检测到与 CanvasRenderingContext2D 或 OffscreenCanvasRenderingContext2D 上下文关联的后备存储已丢失，则它必须为每个此类上下文运行上下文丢失步骤：
        1. 如果 context 是 CanvasRenderingContext2D，则让 canvas 为 context 的 canvas 属性的值，否则为 context 的关联 OffscreenCanvas 对象。
        2. 将上下文的上下文丢失设置为真。
        3. 将渲染上下文重置为其给定上下文的默认状态。
        4. 让 shouldRestore 是在画布上触发一个名为 contextlost 的事件的结果，cancelable 属性初始化为 true。
        5. 如果 shouldRestore 为 false，则中止这些步骤。
        6. 尝试通过使用上下文的属性创建后备存储并将它们与上下文相关联来恢复上下文。 如果失败，则中止这些步骤。
        7. 将上下文的上下文丢失设置为 false。
        8. 在画布上触发一个名为 contextrestored 的事件。
    13. 对于文档中的每个完全活动的文档，运行该文档的动画帧回调，现在作为时间戳传入。
    14. 对于文档中的每个完全活动的文档，运行该文档的更新交叉观察步骤，现在作为时间戳传入。
    15. 为文档中的每个 Document 对象调用标记绘制计时算法。
    16. 对于文档中的每个完全活动的文档，更新该文档的渲染或用户界面及其浏览上下文以反映当前状态。
12. 如果以下所有情况都为真

    - 这是一个窗口事件循环
    - 此事件循环的任务队列中没有文档完全处于活动状态的任务
    - 此事件循环的微任务队列为空
    - hasARenderingOpportunity 是 false

    然后对于其相关代理的事件循环是此事件循环的每个 Window 对象，运行启动空闲期算法，传递 Window。

13. 如果这是一个工作线程事件循环，则：
    1. 如果此事件循环的代理的单个领域的全局对象是受支持的 DedicatedWorkerGlobalScope 并且用户代理认为此时更新其渲染会受益，则：
       1. 令 now 为当前的高解析度时间。
       2. 运行该 DedicatedWorkerGlobalScope 的动画帧回调，现在作为时间戳传入。
       3. 更新该专用工作线程的渲染以反映当前状态。
       4. > 注意: 类似于在窗口事件循环中更新渲染的注意事项，用户代理可以确定专用工作线程中的渲染速率。。
    2. 如果事件循环的任务队列中没有任务并且 WorkerGlobalScope 对象的关闭标志为真，则销毁事件循环，中止这些步骤，继续运行下面 Web 工作线程部分中描述的工作步骤。

当用户代理`执行微任务检查点`时:

1. 如果事件循环的`执行微任务检查点`为 true，则返回。
2. 将事件循环的`执行微任务检查点`设置为 true。
3. 当事件循环的`微任务队列`不为空时:
   1. 让`最老微任务`从事件循环的`微任务队列`中`出列`。
   2. 将事件循环的`当前运行任务`设置为`最老微任务`。
   3. 运行`最老微任务`。
      > 注意：这可能涉及调用脚本回调，该回调最终在运行脚本步骤后调用清理，调用该回调再次执行微任务检查点算法，这就是为什么我们使用`执行微任务检查点`标志来避免重入。
   4. 将事件循环的`当前运行任务`设置为空。
4. 每一个`environment settings object`的`responsible event loop`就是当前的事件循环，会给`environment settings object`发一个`rejected promise`的通知。
5. 清理`IndexDB`事务。
6. 执行`ClearKeptObjects()`。
   > 当 `WeakRef.prototype.deref()` 返回一个对象时，该对象将保持活着的状态，直到下一次调用 ClearKeptObjects()，之后它将再次触发垃圾回收`GC`。
7. 将事件循环的`执行微任务检查点`设置为 false。

## 8.1.6.4 Generic task sources - 通用的任务源

本规范和其他规范中的许多几乎不相关的功能使用以下任务源。

**The DOM manipulation task source - DOM 操作任务源**
此任务源用于对 DOM 操作做出反应的功能，例如在将元素插入文档时以非阻塞方式发生的事情。

**The user interaction task source - 用户交互任务源**
此任务源用于对用户交互做出反应的功能，例如键盘或鼠标输入。
响应用户输入而发送的事件（例如点击事件）必须使用与用户交互任务源一起排队的任务来触发。

**The networking task source - 网络任务源**
此任务源用于响应网络活动而触发的功能。

**The history traversal task source - 历史遍历任务源**
此任务源用于对`history.back()`和类似`API`的调用进行排队。
